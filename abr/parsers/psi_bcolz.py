'''
Interface for reading tone-evoked ABR data generated by psiexperiment

This supports merging across aggregate files. Right now there's no support for
reading from the raw (i.e., untrial_filtered) data. Maybe eventually. It wouldn't be
hard to add, but would need support for trial_filter specs as well as ensuring that we
pull out enough pre/post samples for proper trial_filtering.
'''
import os.path
import shutil
import re
from glob import glob

import bcolz
import numpy as np
import pandas as pd
from scipy import signal


FILE_PATTERN = \
    r'(?P<date>\d{8})-' \
    r'(?P<time>\d{4}) ' \
    r'(?P<experimenter>\w+) ' \
    r'(?P<animal>[\w\.]+) ' \
    r'(?P<ear>(right|left)+) ' \
    r'(?P<note>[\w\s]+) ' \
    r'(?P<experiment>abr)' \
    r'\s?(?P<round>\d+)?'


FILE_RE = re.compile(FILE_PATTERN)

MERGE_PATTERN = \
    r'\g<date>-* ' \
    r'\g<experimenter> ' \
    r'\g<animal> ' \
    r'\g<ear> ' \
    r'\g<note> ' \
    r'\g<experiment>*'


def fix_polarity_column(table):
    col = table['target_tone_polarity']
    if col.dtype != np.object:
        return
    tp = col[:].astype(np.int)
    table.delcol('target_tone_polarity')
    table.addcol(tp, 'target_tone_polarity')


def fix_epoch_size(table):
    if 'epoch_size' not in table.names:
        data = np.full(len(table), 8.5e-3)
        table.addcol(data, 'epoch_size')


class ABRFile:

    def __init__(self, base_folder):
        self._base_folder = base_folder
        self._eeg_folder = os.path.join(base_folder, 'eeg')
        self._erp_folder = os.path.join(base_folder, 'erp')
        self._erp_md_folder = os.path.join(base_folder, 'erp_metadata')
        self._eeg = bcolz.carray(rootdir=self._eeg_folder)
        self._erp = bcolz.carray(rootdir=self._erp_folder)
        self._erp_md = bcolz.ctable(rootdir=self._erp_md_folder)
        self.trial_log = self._erp_md.todataframe()

        # Run some fixers
        fix_polarity_column(self._erp_md)
        fix_epoch_size(self._erp_md)

        epoch_size = self._erp_md['epoch_size'][:]
        e_size = epoch_size * self._erp.attrs['fs']
        e_size = np.round(e_size).astype('int64')
        e_index = e_size.cumsum() - e_size[0]
        self._e_index = e_index
        self._e_size = e_size

        t0 = self._erp_md['t0'][:]
        c_index = t0 * self._eeg.attrs['fs']
        c_index = np.round(c_index).astype('int64')
        c_size = epoch_size * self._eeg.attrs['fs']
        c_size = np.round(c_size).astype('int64')
        self._c_index = c_index
        self._c_size = c_size

    def get_epochs(self, trial_filter, offset=0, reject_threshold=np.inf,
                   signal_filter=None, base_name='target_tone_'):

        if base_name is not None:
            trial_filter = trial_filter.copy()
            trial_filter = {'{}{}'.format(base_name, k): v \
                            for k, v in trial_filter.items()}

        fs = self._eeg.attrs['fs']

        if signal_filter is not None:
            fl = signal_filter['fl']
            fh = signal_filter['fh']
            Wn = fl/fs, fh/fs
            btype = signal_filter['btype']
            ftype = signal_filter['ftype']
            N = signal_filter['order']
            b, a = signal.iirfilter(N=N, Wn=Wn, btype=btype, ftype=ftype)
            n_taps = max(len(b), len(a))*3
        else:
            n_taps = 0

        queries = ['({} == {})'.format(k, v) for k, v in trial_filter.items()]
        query = ' & '.join(queries)
        epochs = []
        offset_i = int(round(fs * offset))
        for row, in self._erp_md.where(query, outcols='nrow__'):
            lb = self._c_index[row] + offset_i - n_taps
            ub = lb + self._c_size[row] + n_taps
            epoch = self._eeg[lb:ub]
            if signal_filter is not None:
                epoch = signal.filtfilt(b, a, epoch)

            if np.any(np.abs(epoch) >= reject_threshold):
                continue
            else:
                if signal_filter is not None:
                    epochs.append(epoch[n_taps:-n_taps][np.newaxis])
                else:
                    epochs.append(epoch[np.newaxis])

        return np.concatenate(epochs, axis=0)

    def get_epochs_combined_polarity(self, trial_filter, *args, **kwargs):
        trial_filter = trial_filter.copy()
        trial_filter['polarity'] = 1
        p_epochs = self.get_epochs(trial_filter, *args, **kwargs)
        trial_filter['polarity'] = -1
        n_epochs = self.get_epochs(trial_filter, *args, **kwargs)
        n = min(len(p_epochs), len(n_epochs))
        p_epochs = p_epochs[:n]
        n_epochs = n_epochs[:n]
        return np.concatenate((p_epochs, n_epochs), axis=0)

    def get_epoch_groups(self, *columns):
        groups = self.count_epochs(*columns)
        results = []
        keys = []
        for index, _ in groups.iteritems():
            trial_filter = {c: i for c, i in zip(columns, index)}
            epochs = self.get_epochs(trial_filter)
            keys.append(index)
            results.append(epochs)
        index = pd.MultiIndex.from_tuples(keys, names=columns)
        return pd.Series(results, index=index, name='epochs')

    def count_epochs(self, columns):
        base_name = 'target_tone_'
        column_names = ['{}{}'.format(base_name, c) for c in columns]
        sizes = self.trial_log.groupby(column_names).size()
        sizes.index.names = columns
        return sizes

    def count_epochs_combined_polarity(self, columns):
        sizes = self.count_epochs(['polarity'] + list(columns))
        return sizes.unstack('polarity').min(axis=1) * 2

    @property
    def fs(self):
        return self._eeg.attrs['fs']


class ABRSupersetFile:

    def __init__(self, *base_folders):
        self._fh = [ABRFile(base_folder) for base_folder in base_folders]

    def get_epochs(self, **kwargs):
        epoch_superset = []
        for fh in self._fh:
            epochs = fh.get_epochs(**kwargs)
            epoch_superset.append(epochs)
        return np.concatenate(epoch_superset, axis=0)

    def count_epochs(self, *columns):
        counts = self._fh[0].count_epochs(*columns)
        for fh in self._fh[1:]:
            new_counts = fh.count_epochs(*columns)
            counts = counts.add(new_counts, fill_value=0)
        return counts

    def get_epoch_groups(self, *columns):
        groups = self.count_epochs(*columns)
        results = []
        keys = []
        for index, _ in groups.iteritems():
            kwargs = {c: i for c, i in zip(columns, index)}
            epochs = self.get_epochs(**kwargs)
            keys.append(index)
            results.append(epochs)
        index = pd.MultiIndex.from_tuples(keys, names=columns)
        return pd.Series(results, index=index, name='epochs')

    def get_average(self, **kwargs):
        return self.get_epochs(**kwargs).mean(axis=0)

    @classmethod
    def from_pattern(cls, base_folder):
        head, tail = os.path.split(base_folder)
        glob_tail = FILE_RE.sub(MERGE_PATTERN, tail)
        glob_pattern = os.path.join(head, glob_tail)
        folders = glob(glob_pattern)
        cls(*folders)

    @classmethod
    def from_folder(cls, base_folder):
        folders = os.listdir(base_folder)
        folders = [os.path.join(base_folder, f) for f in folders]
        return cls(*folders)

    @property
    def fs(self):
        fs = [fh.fs for fh in self._fh]
        if len(set(fs)) != 1:
            raise ValueError('Sampling rate of ABR sets differ')
        return fs[0]


def load(base_folder):
    check = os.path.join(base_folder, 'erp')
    if os.path.exists(check):
        return ABRFile(base_folder)
    else:
        return ABRSupersetFile.from_folder(base_folder)
