'''
Interface for reading tone-evoked ABR data generated by psiexperiment

This supports merging across aggregate files. Right now there's no support for
reading from the raw (i.e., unfiltered) data. Maybe eventually. It wouldn't be
hard to add, but would need support for filter specs as well as ensuring that we
pull out enough pre/post samples for proper filtering.
'''
import os.path
import shutil
import re
from glob import glob

import bcolz
import numpy as np
import pandas as pd


FILE_PATTERN = \
    r'(?P<date>\d{8})-' \
    r'(?P<time>\d{4}) ' \
    r'(?P<experimenter>\w+) ' \
    r'(?P<animal>[\w\.]+) ' \
    r'(?P<ear>(right|left)+) ' \
    r'(?P<note>[\w\s]+) ' \
    r'(?P<experiment>abr)' \
    r'\s?(?P<round>\d+)?'


FILE_RE = re.compile(FILE_PATTERN)

MERGE_PATTERN = \
    r'\g<date>-* ' \
    r'\g<experimenter> ' \
    r'\g<animal> ' \
    r'\g<ear> ' \
    r'\g<note> ' \
    r'\g<experiment>*'


def fix_polarity_column(table):
    col = table['target_tone_polarity']
    if col.dtype != np.object:
        return
    tp = col[:].astype(np.int)
    table.delcol('target_tone_polarity')
    table.addcol(tp, 'target_tone_polarity')


def fix_epoch_size(table):
    if 'epoch_size' not in table.names:
        data = np.full(len(table), 8.5e-3)
        table.addcol(data, 'epoch_size')


class ABRFile:

    def __init__(self, base_folder):
        self._base_folder = base_folder
        self._eeg_folder = os.path.join(base_folder, 'eeg')
        self._erp_folder = os.path.join(base_folder, 'erp')
        self._erp_md_folder = os.path.join(base_folder, 'erp_metadata')
        self._eeg = bcolz.carray(rootdir=self._eeg_folder)
        self._erp = bcolz.carray(rootdir=self._erp_folder)
        self._erp_md = bcolz.ctable(rootdir=self._erp_md_folder)

        # Run some fixers
        fix_polarity_column(self._erp_md)
        fix_epoch_size(self._erp_md)

        epoch_size = self._erp_md['epoch_size'][:]
        e_size = epoch_size * self._erp.attrs['fs']
        e_size = np.round(e_size).astype('int64')
        e_index = e_size.cumsum() - e_size[0]
        self._e_index = e_index
        self._e_size = e_size

        t0 = self._erp_md['t0'][:]
        c_index = t0 * self._eeg.attrs['fs']
        c_index = np.round(c_index).astype('int64')
        self._c_index = c_index

    def _get_epochs(self, reject_threshold=2.5, **kwargs):
        queries = ['({} == {})'.format(k, v) for k, v in kwargs.items()]
        query = ' & '.join(queries)
        epochs = []
        for row, in self._erp_md.where(query, outcols='nrow__'):
            lb = self._e_index[row]
            ub = lb + self._e_size[row]
            epoch = self._erp[lb:ub]
            if np.any(np.abs(epoch) >= reject_threshold):
                continue
            epochs.append(epoch[np.newaxis])
        return np.concatenate(epochs, axis=0)

    def get_epochs(self, **kwargs):
        base_name = 'target_tone_'
        kwargs['polarity'] = 1
        p_kw = {'{}{}'.format(base_name, k): v for k, v in kwargs.items()}
        kwargs['polarity'] = -1
        n_kw = {'{}{}'.format(base_name, k): v for k, v in kwargs.items()}
        p_epochs = self._get_epochs(**p_kw)
        n_epochs = self._get_epochs(**n_kw)
        n = min(len(p_epochs), len(n_epochs))
        p_epochs = p_epochs[:n]
        n_epochs = n_epochs[:n]
        return np.concatenate((p_epochs, n_epochs), axis=0)

    def get_epoch_groups(self, *columns):
        groups = self.count_epochs(*columns)
        results = []
        keys = []
        for index, _ in groups.iteritems():
            kwargs = {c: i for c, i in zip(columns, index)}
            epochs = self.get_epochs(**kwargs)
            keys.append(index)
            results.append(epochs)
        index = pd.MultiIndex.from_tuples(keys, names=columns)
        return pd.Series(results, index=index, name='epochs')

    def get_average(self, **kwargs):
        return self.get_epochs(**kwargs).mean(axis=0)

    def count_epochs(self, *columns):
        base_name = 'target_tone_'
        columns = ['polarity'] + list(columns)
        column_names = ['{}{}'.format(base_name, c) for c in columns]
        df = self._erp_md[column_names].todataframe()
        df.columns = columns
        sizes = df.groupby(columns).size()
        return sizes.unstack('polarity').min(axis=1) * 2

    @property
    def fs(self):
        return self._erp.attrs['fs']


class ABRSupersetFile:

    def __init__(self, *base_folders):
        self._fh = [ABRFile(base_folder) for base_folder in base_folders]

    def get_epochs(self, **kwargs):
        epoch_superset = []
        for fh in self._fh:
            epochs = fh.get_epochs(**kwargs)
            epoch_superset.append(epochs)
        return np.concatenate(epoch_superset, axis=0)

    def count_epochs(self, *columns):
        counts = self._fh[0].count_epochs(*columns)
        for fh in self._fh[1:]:
            new_counts = fh.count_epochs(*columns)
            counts = counts.add(new_counts, fill_value=0)
        return counts

    def get_epoch_groups(self, *columns):
        groups = self.count_epochs(*columns)
        results = []
        keys = []
        for index, _ in groups.iteritems():
            kwargs = {c: i for c, i in zip(columns, index)}
            epochs = self.get_epochs(**kwargs)
            keys.append(index)
            results.append(epochs)
        index = pd.MultiIndex.from_tuples(keys, names=columns)
        return pd.Series(results, index=index, name='epochs')

    def get_average(self, **kwargs):
        return self.get_epochs(**kwargs).mean(axis=0)

    @classmethod
    def from_pattern(cls, base_folder):
        head, tail = os.path.split(base_folder)
        glob_tail = FILE_RE.sub(MERGE_PATTERN, tail)
        glob_pattern = os.path.join(head, glob_tail)
        folders = glob(glob_pattern)
        cls(*folders)

    @classmethod
    def from_folder(cls, base_folder):
        folders = os.listdir(base_folder)
        folders = [os.path.join(base_folder, f) for f in folders]
        return cls(*folders)

    @property
    def fs(self):
        fs = [fh.fs for fh in self._fh]
        if len(set(fs)) != 1:
            raise ValueError('Sampling rate of ABR sets differ')
        return fs[0]


def load(base_folder):
    check = os.path.join(base_folder, 'erp')
    if os.path.exists(check):
        return ABRFile(base_folder)
    else:
        return ABRSupersetFile.from_folder(base_folder)
