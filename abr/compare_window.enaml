from enaml.application import deferred_call
from enaml.layout.api import align, grid, hbox, vbox
from enaml.styling import StyleSheet, Style, Setter
from enaml.widgets.api import Container, Label, MainWindow, ObjectCombo

from abr import main_icon
from abr.main_window import ABRCanvas, fmt_freq, mpl_connect, MPLContainer


enamldef CompareStyle(StyleSheet):

    Style:
        element = 'Label'
        style_class = 'emphasis'
        Setter:
            field = 'padding'
            value = '5px'
        Setter:
            field = 'font'
            value = '14pt Verdana bold'


enamldef CompareWindow(MainWindow): window:

    CompareStyle:
        pass

    attr compare
    attr parser
    attr layout

    alias presenter_a: rater_a_plot.presenter
    alias presenter_b: rater_b_plot.presenter
    alias presenter_c: rater_c_plot.presenter

    initial_size = (600, 900)
    title = 'ABR batch mode'
    icon = main_icon

    initial_size = (1000, 800)
    icon = main_icon

    initialized ::
        compare.observe('selected_points', selected_changed)

    func selected_changed(event):
        if compare.selected_points:
            filename, frequency, level, replicate, analysis_a, analysis_b = \
                compare.selected_points[0]
            point = compare.selected_feature.split(' ')[0]

            update_model = False
            update_selection = True

            if presenter_a.model is None or \
                    presenter_a.model.filename != filename or \
                    presenter_a.model.freq != frequency:
                update_model = True

                if presenter_c.modified:
                    mesg = 'Changes to the analysis are not saved. Discard these changes?'
                    result = question(self, 'Analysis not saved', mesg)
                    if result.text == 'No':
                        update_model = False
                        update_selection = False

            if update_model:
                model = parser.load(filename, [frequency])[0]
                presenter_a.load(model)
                presenter_a.load_analysis(analysis_a)

                model = parser.load(filename, [frequency])[0]
                presenter_b.load(model)
                presenter_b.load_analysis(analysis_b)

                model = parser.load(filename, [frequency])[0]
                presenter_c.load(model)
                rater_c_plot.analyzed_filenames = \
                    parser.find_analyzed_files(filename, frequency)

                plot_title.text = f'{filename} {fmt_freq(frequency)}'

            if update_selection:
                presenter_a.select_waveform(level, replicate)
                presenter_a.select_point(point)
                presenter_b.select_waveform(level, replicate)
                presenter_b.select_point(point)

    Container:
        layout_constraints => ():
            first_line = [show_label, feature, for_label, x_select, and1_label, y_select]
            second_line = [plotas_label, plot_mode, and2_label, jitter_mode]
            third_line = [selected_label, plot_title]
            canvas_box = vbox(
                hbox(*first_line),
                hbox(*second_line),
                hbox(*third_line),
                canvas
            )

            if window.layout == 'long':
                layout = hbox(
                    canvas_box,
                    vbox(
                        hbox(
                            vbox(rater_a_label, rater_a_plot),
                            vbox(rater_b_label, rater_b_plot),
                            vbox(rater_c_label, rater_c_plot),
                        ),
                    ),
                )
            else:
                layout = grid([canvas_box,                          vbox(rater_c_label, rater_c_plot)],
                              [vbox(rater_a_label, rater_a_plot),   vbox(rater_b_label, rater_b_plot)])

            return [
                layout,
                align('v_center', *first_line),
                align('v_center', *second_line),
                align('v_center', *third_line),
                align('width', rater_a_plot, rater_b_plot, rater_c_plot),
                align('height', rater_a_plot, rater_b_plot, rater_c_plot),
                x_select.width == y_select.width,
            ]

        ObjectCombo: feature:
            items << compare.available_features
            selected := compare.selected_feature

        Label: show_label:
            text = 'Show'

        Label: for_label:
            text = 'for rater'

        Label: and1_label:
            text = 'and'

        ObjectCombo: x_select:
            items << compare.available_raters
            selected := compare.rater_x

        ObjectCombo: y_select:
            items << compare.available_raters
            selected := compare.rater_y

        Label: plotas_label:
            text = 'Plot as'

        ObjectCombo: plot_mode:
            items << ['actual values', 'difference between raters']
            selected ::
                compare.as_difference = not(selected == 'actual values')

        Label: and2_label:
            text = 'and'

        ObjectCombo: jitter_mode:
            items << ["don't jitter data", "jitter data"]
            selected ::
                compare.jitter = selected == 'jitter data'

        Label: selected_label:
            text = 'Selected point'

        ABRCanvas: canvas:
            figure << compare.figure
            initialized ::
                deferred_call(mpl_connect, compare.figure, 'button_press_event',
                              compare.button_press_event)

        MPLContainer: rater_a_plot:
            interactive = False

        MPLContainer: rater_b_plot:
            interactive = False

        MPLContainer: rater_c_plot:
            pass

        Label: rater_a_label:
            text << 'Rater ' + compare.rater_x
            style_class = 'emphasis'

        Label: rater_b_label:
            text << 'Rater ' + compare.rater_y
            style_class = 'emphasis'

        Label: rater_c_label:
            text << 'Rater ' + parser._user
            style_class = 'emphasis'

        Label: plot_title:
            text = 'Please select a point to load'
